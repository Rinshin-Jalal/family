// ============================================================================
// AUDIO PROCESSOR - Weave audio clips into podcasts
// ============================================================================
//
// Uses trigger.dev's built-in ffmpeg for audio processing:
// - Downloads TTS-generated audio clips
// - Concatenates with crossfades using ffmpeg
// - Mixes with background music
// - Uploads to Supabase storage
//
// All audio is generated by Cartesia TTS, then processed with ffmpeg.
// ============================================================================

import { MusicLibrary, type MusicConfig, type MusicStyle } from './music-library'
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)

// ============================================================================
// TYPES
// ============================================================================

export interface AudioProcessorConfig {
  outputFormat: 'mp3' | 'wav' | 'm4a'
  audioQuality: 'low' | 'medium' | 'high'

  // Processing options
  crossfadeDuration: number  // seconds

  // Music configuration
  music?: Partial<MusicConfig>

  // Storage options
  storage?: 'supabase' | 'callback'
  uploadCallback?: (buffer: Buffer, key: string) => Promise<{ url: string }>
  supabase?: any // Supabase client for storage uploads
}

export interface AudioClip {
  id: string
  url: string
  speakerName: string
  duration?: number
}

export interface PodcastGenerationInput {
  storyId: string
  audioClips: AudioClip[]
  storySummary?: string  // For music style selection
  outputFormat?: 'mp3' | 'wav' | 'm4a'
  musicStyle?: MusicStyle
  addMusic?: boolean
}

export interface PodcastGenerationResult {
  podcastUrl: string
  duration: number
  format: string
  fileSize: number
  clipCount: number
}

// ============================================================================
// AUDIO PROCESSOR SERVICE
// ============================================================================

export class AudioProcessor {
  private config: AudioProcessorConfig
  private musicLibrary: MusicLibrary

  constructor(config: AudioProcessorConfig) {
    this.config = config
    this.musicLibrary = new MusicLibrary(config.music)
  }

  /**
   * Generate a podcast from audio clips
   *
   * All clips should already be TTS-generated audio from Cartesia.
   * This method concatenates them with crossfades and optional music using ffmpeg.
   */
  async generatePodcast(input: PodcastGenerationInput): Promise<PodcastGenerationResult> {
    try {
      // Extract URLs from clips
      const urls = input.audioClips.map(clip => clip.url)

      // Step 1: Concatenate audio with crossfades using ffmpeg
      const concatenatedBuffer = await this.concatenateAudio(urls)

      // Step 2: Add background music if requested
      const finalBuffer = input.addMusic
        ? await this.mixWithMusic(concatenatedBuffer, input.musicStyle)
        : concatenatedBuffer

      // Step 3: Upload and return URL
      return await this.finalizePodcast(
        { audioBuffer: finalBuffer, duration: this.calculateDuration(finalBuffer) },
        input.storyId
      )
    } catch (error) {
      throw this.handleError(error)
    }
  }

  /**
   * Concatenate audio files using ffmpeg
   *
   * Uses trigger.dev's built-in ffmpeg to properly concatenate
   * audio files with crossfades.
   */
  private async concatenateAudio(urls: string[]): Promise<ArrayBuffer> {
    const ffmpegPath = process.env.FFMPEG_PATH || 'ffmpeg'

    // Create temporary directory for processing
    const tmpDir = `/tmp/podcast-${Date.now()}`
    await execAsync(`mkdir -p ${tmpDir}`)

    try {
      // Download all audio files to temp directory
      for (let i = 0; i < urls.length; i++) {
        const response = await fetch(urls[i])
        const buffer = await response.arrayBuffer()
        await execAsync(`curl -s "${urls[i]}" -o "${tmpDir}/clip${i}.mp3"`)
      }

      // Create concat file for ffmpeg
      const concatFile = `${tmpDir}/concat.txt`
      const concatContent = urls.map((_, i) => `file 'clip${i}.mp3'`).join('\n')
      await execAsync(`cat > "${concatFile}" << 'EOF'\n${concatContent}\nEOF`)

      // Use ffmpeg to concatenate with crossfades
      const outputPath = `${tmpDir}/output.mp3`
      const crossfadeDuration = this.config.crossfadeDuration

      if (urls.length === 1) {
        // Single file - just copy it
        await execAsync(`cp "${tmpDir}/clip0.mp3" "${outputPath}"`)
      } else {
        // Multiple files - concatenate with crossfades
        // Build ffmpeg filter for concatenation
        const filterComplex = urls.map((_, i) => {
          if (i === 0) {
            return `[0:a]afade=t=out:st=5:d=${crossfadeDuration}[a0]`
          } else if (i === urls.length - 1) {
            return `[${i}:a]afade=t=in:st=0:d=${crossfadeDuration}[a${i}]`
          } else {
            return `[${i}:a]afade=t=in:st=0:d=${crossfadeDuration},afade=t=out:st=5:d=${crossfadeDuration}[a${i}]`
          }
        }).join(';')

        const inputs = urls.map((_, i) => `-i "${tmpDir}/clip${i}.mp3"`).join(' ')
        const filter = `${filterComplex};${urls.map((_, i) => `[a${i}]`).join('')}concat=n=${urls.length}:v=0:a=1[out]`

        await execAsync(
          `"${ffmpegPath}" ${inputs} -filter_complex "${filter}" -map "[out]" "${outputPath}"`
        )
      }

      // Read the output file
      const { stdout } = await execAsync(`cat "${outputPath}"`)
      return Buffer.from(stdout, 'binary').buffer

    } finally {
      // Cleanup temp directory
      await execAsync(`rm -rf "${tmpDir}"`)
    }
  }

  /**
   * Mix audio with background music using ffmpeg
   */
  private async mixWithMusic(
    audioBuffer: ArrayBuffer,
    musicStyle?: MusicStyle
  ): Promise<ArrayBuffer> {
    const ffmpegPath = process.env.FFMPEG_PATH || 'ffmpeg'
    const musicTrack = musicStyle ? this.musicLibrary.getTrack(musicStyle) : null

    if (!musicTrack) {
      return audioBuffer
    }

    const tmpDir = `/tmp/podcast-mix-${Date.now()}`
    await execAsync(`mkdir -p ${tmpDir}`)

    try {
      // Write audio buffer to temp file
      const audioPath = `${tmpDir}/audio.mp3`
      await execAsync(`cat > "${audioPath}" << 'EOF'\n${Buffer.from(audioBuffer).toString('base64')}\nEOF`)

      // Download music track
      const musicPath = `${tmpDir}/music.mp3`
      await execAsync(`curl -s "${musicTrack.url}" -o "${musicPath}"`)

      // Mix with background music using ffmpeg
      const outputPath = `${tmpDir}/output.mp3`

      await execAsync(
        `"${ffmpegPath}" -i "${audioPath}" -i "${musicPath}" ` +
        `-filter_complex ` +
        `"[0:a]volume=2[audio];[1:a]volume=${musicTrack.volume},afade=t=in:st=0:d=${musicTrack.fadeIn},afade=t=out:st=30:d=${musicTrack.fadeOut}[music];` +
        `[audio][music]amix=inputs=2:duration=first:dropout_transition=2" ` +
        `"${outputPath}"`
      )

      // Read the output file
      const { stdout } = await execAsync(`cat "${outputPath}"`)
      return Buffer.from(stdout, 'binary').buffer

    } catch (error) {
      // If music mixing fails, return original audio
      console.error('Failed to mix music, returning original audio:', error)
      return audioBuffer
    } finally {
      // Cleanup temp directory
      await execAsync(`rm -rf "${tmpDir}"`)
    }
  }

  /**
   * Calculate approximate audio duration from buffer
   */
  private calculateDuration(buffer: ArrayBuffer): number {
    // Rough estimate: assume MP3 at 128kbps
    const bitsPerSecond = 128000
    return (buffer.byteLength * 8) / bitsPerSecond
  }

  /**
   * Finalize podcast: upload to storage, return URL
   */
  private async finalizePodcast(
    result: { audioBuffer: ArrayBuffer; duration: number },
    storyId: string
  ): Promise<PodcastGenerationResult> {
    const buffer = Buffer.from(result.audioBuffer)
    const timestamp = Date.now()
    const fileName = `${timestamp}_podcast.${this.config.outputFormat}`

    let podcastUrl: string

    if (this.config.uploadCallback) {
      // Use custom callback
      const uploadResult = await this.config.uploadCallback(buffer, fileName)
      podcastUrl = uploadResult.url
    } else if (this.config.storage === 'supabase' && this.config.supabase) {
      // Upload to Supabase storage
      const filePath = `podcasts/${storyId}/${fileName}`

      const { data, error } = await this.config.supabase.storage
        .from('podcasts')
        .upload(filePath, buffer, {
          contentType: `audio/${this.config.outputFormat}`,
          upsert: false,
        })

      if (error) {
        throw new Error(`Supabase upload failed: ${error.message}`)
      }

      const { data: { publicUrl } } = this.config.supabase.storage
        .from('podcasts')
        .getPublicUrl(filePath)

      podcastUrl = publicUrl
    } else {
      throw new Error('No valid storage configured. Provide storage or uploadCallback.')
    }

    return {
      podcastUrl,
      duration: result.duration,
      format: this.config.outputFormat,
      fileSize: result.audioBuffer.byteLength,
      clipCount: 1,
    }
  }

  /**
   * Handle and normalize errors
   */
  private handleError(error: unknown): Error {
    const err = error as Error
    return new Error(`Audio processing failed: ${err.message}`)
  }

  /**
   * Determine if an error is retryable
   */
  private isRetryable(error: Error): boolean {
    const retryablePatterns = [
      /timeout/i,
      /network/i,
      /rate limit/i,
      /temporary/i,
      /5\d\d/,  // 5xx errors
    ]

    return retryablePatterns.some(pattern => pattern.test(error.message))
  }

  /**
   * Health check for audio processor
   */
  async healthCheck(): Promise<boolean> {
    try {
      // Check if we can download a test file
      const testResponse = await fetch('https://httpbin.org/get', { method: 'HEAD' })
      return testResponse.ok
    } catch {
      return false
    }
  }

  /**
   * Update configuration
   */
  updateConfig(updates: Partial<AudioProcessorConfig>): void {
    this.config = { ...this.config, ...updates }

    // Update music library config if provided
    if (updates.music) {
      this.musicLibrary.updateConfig(updates.music)
    }
  }

  /**
   * Get current configuration
   */
  getConfig(): AudioProcessorConfig {
    return { ...this.config }
  }
}

// ============================================================================
// FACTORY FUNCTION
// ============================================================================

export function createAudioProcessor(config: AudioProcessorConfig): AudioProcessor {
  return new AudioProcessor(config)
}

// ============================================================================
// DEFAULT CONFIGURATION
// ============================================================================

export const DEFAULT_AUDIO_PROCESSOR_CONFIG: AudioProcessorConfig = {
  outputFormat: 'mp3',
  audioQuality: 'high',
  crossfadeDuration: 1.5,
  music: {
    enabled: true,
    style: 'warm',
    volume: 0.25,
    fadeInDuration: 2,
    fadeOutDuration: 3,
  },
  storage: 'supabase',
}
